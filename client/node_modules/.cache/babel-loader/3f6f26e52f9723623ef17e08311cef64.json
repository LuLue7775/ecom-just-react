{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexport default function autoMergeLevel2(inboundState, originalState, reducedState, _ref) {\n  var debug = _ref.debug;\n\n  var newState = _extends({}, reducedState); // only rehydrate if inboundState exists and is an object\n\n\n  if (inboundState && (typeof inboundState === 'undefined' ? 'undefined' : _typeof(inboundState)) === 'object') {\n    Object.keys(inboundState).forEach(function (key) {\n      // ignore _persist data\n      if (key === '_persist') return; // if reducer modifies substate, skip auto rehydration\n\n      if (originalState[key] !== reducedState[key]) {\n        if (process.env.NODE_ENV !== 'production' && debug) console.log('redux-persist/stateReconciler: sub state for key `%s` modified, skipping.', key);\n        return;\n      }\n\n      if (isPlainEnoughObject(reducedState[key])) {\n        // if object is plain enough shallow merge the new values (hence \"Level2\")\n        newState[key] = _extends({}, newState[key], inboundState[key]);\n        return;\n      } // otherwise hard set\n\n\n      newState[key] = inboundState[key];\n    });\n  }\n\n  if (process.env.NODE_ENV !== 'production' && debug && inboundState && (typeof inboundState === 'undefined' ? 'undefined' : _typeof(inboundState)) === 'object') console.log('redux-persist/stateReconciler: rehydrated keys \\'' + Object.keys(inboundState).join(', ') + '\\'');\n  return newState;\n}\n/*\n  autoMergeLevel2: \n    - merges 2 level of substate\n    - skips substate if already modified\n    - this is essentially redux-perist v4 behavior\n*/\n\nfunction isPlainEnoughObject(o) {\n  return o !== null && !Array.isArray(o) && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object';\n}","map":{"version":3,"sources":["F:/XAMPP/htdocs/ecom-just-react/node_modules/redux-persist/es/stateReconciler/autoMergeLevel2.js"],"names":["_typeof","Symbol","iterator","obj","constructor","prototype","_extends","Object","assign","target","i","arguments","length","source","key","hasOwnProperty","call","autoMergeLevel2","inboundState","originalState","reducedState","_ref","debug","newState","keys","forEach","process","env","NODE_ENV","console","log","isPlainEnoughObject","join","o","Array","isArray"],"mappings":"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","sourcesContent":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexport default function autoMergeLevel2(inboundState, originalState, reducedState, _ref) {\n  var debug = _ref.debug;\n\n  var newState = _extends({}, reducedState);\n  // only rehydrate if inboundState exists and is an object\n  if (inboundState && (typeof inboundState === 'undefined' ? 'undefined' : _typeof(inboundState)) === 'object') {\n    Object.keys(inboundState).forEach(function (key) {\n      // ignore _persist data\n      if (key === '_persist') return;\n      // if reducer modifies substate, skip auto rehydration\n      if (originalState[key] !== reducedState[key]) {\n        if (process.env.NODE_ENV !== 'production' && debug) console.log('redux-persist/stateReconciler: sub state for key `%s` modified, skipping.', key);\n        return;\n      }\n      if (isPlainEnoughObject(reducedState[key])) {\n        // if object is plain enough shallow merge the new values (hence \"Level2\")\n        newState[key] = _extends({}, newState[key], inboundState[key]);\n        return;\n      }\n      // otherwise hard set\n      newState[key] = inboundState[key];\n    });\n  }\n\n  if (process.env.NODE_ENV !== 'production' && debug && inboundState && (typeof inboundState === 'undefined' ? 'undefined' : _typeof(inboundState)) === 'object') console.log('redux-persist/stateReconciler: rehydrated keys \\'' + Object.keys(inboundState).join(', ') + '\\'');\n\n  return newState;\n}\n\n/*\n  autoMergeLevel2: \n    - merges 2 level of substate\n    - skips substate if already modified\n    - this is essentially redux-perist v4 behavior\n*/\n\nfunction isPlainEnoughObject(o) {\n  return o !== null && !Array.isArray(o) && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object';\n}"]},"metadata":{},"sourceType":"module"}